package cplib

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/mjwhitta/errors"
)

// GenerateGo will generate Go source for all of the exports and
// imports provided and write to the provided filename.
func GenerateGo(
	bin string,
	fn string,
	tags string,
	exports []string,
	imports []Import,
) error {
	var i int
	var sb strings.Builder
	var tool string = "github.com/mjwhitta/cplib"

	sb.WriteString(fmt.Sprintf("//go:build %s\n\n", tags))
	sb.WriteString(
		fmt.Sprintf(
			"// Code generated by %s; DO NOT EDIT.\n",
			tool,
		),
	)
	sb.WriteString("package main\n\n")
	sb.WriteString("import \"C\"\n\n")

	for i, ex := range exports {
		if i > 0 {
			sb.WriteString("\n")
		}

		sb.WriteString(
			fmt.Sprintf("// %s from %s.\n", ex, filepath.Base(bin)),
		)
		sb.WriteString(
			fmt.Sprintf("//\n//export %s\nfunc %s() {}\n", ex, ex),
		)
	}

	for _, im := range imports {
		if i > 0 {
			sb.WriteString("\n")
		}

		sb.WriteString(
			fmt.Sprintf(
				"// %s from %s called by %s.\n",
				im.Name,
				im.Lib,
				filepath.Base(bin),
			),
		)
		sb.WriteString(
			fmt.Sprintf(
				"//\n//export %s\nfunc %s() {}\n",
				im.Name,
				im.Name,
			),
		)

		i++
	}

	//nolint:mnd // u+rwx,go=-
	if e := os.MkdirAll(filepath.Dir(fn), 0o700); e != nil {
		return errors.Newf("failed to created directory: %w", e)
	}

	//nolint:mnd // u+rw,go=-
	if e := os.WriteFile(fn, []byte(sb.String()), 0o600); e != nil {
		return errors.Newf("failed to write file: %w", e)
	}

	return nil
}
